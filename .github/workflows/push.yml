# .github/workflows/docker-image.yml
name: Docker Image CI

on:
  push:
    branches: ["main"] # Trigger on pushes to the main branch
  pull_request:
    branches: ["main"] # Trigger on pull requests targeting the main branch

env:
  APP_NAME: reaper-setlist # Your application's base name, e.g., "my-axum-app"
  # Define the raw image ID base. This will be lowercased in a subsequent step.
  IMAGE_ID_RAW: ghcr.io/${{ github.repository }}

jobs:
  # Job to run frontend tests
  test-frontend:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner
    defaults:
      run:
        working-directory: frontend # Assuming your frontend code is in a 'frontend' directory
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4 # Action to checkout your code

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2 # Action to set up the Bun runtime

      - name: Install frontend dependencies
        run: bun install # Install Bun project dependencies

      - name: Run frontend tests
        run: bun test # Execute your frontend tests

  # Job to run backend tests and linting
  test-backend:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner
    defaults:
      run:
        working-directory: backend # Assuming your backend code is in a 'backend' directory
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable # Use a stable Rust toolchain version for consistency

      - name: Install Rust dependencies (and build for tests)
        # `cargo install --locked --path .` will build the binary for testing purposes.
        # For pure dependency fetching without a full build, `cargo fetch` or `cargo check` could be used.
        run: cargo install --locked --path .

      - name: Run Clippy for linting
        run: cargo clippy --locked --all-features -- -D warnings # Enforce no warnings for linting

      - name: Run backend tests
        run: cargo test --locked --all-features # Execute your backend tests

  # Job to build and push the multi-architecture Docker image
  build:
    runs-on: ubuntu-latest # This runner (x86_64) will perform native cross-compilation
    needs: [test-frontend, test-backend] # This job will only run if both test jobs pass

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step to define the fully lowercased IMAGE_ID for consistent use
      - name: Set lowercase IMAGE_ID for GHCR
        id: set_image_id
        run: |
          # Use 'tr' to convert the full raw image ID to lowercase
          # The resulting lowercase ID is then set as a global environment variable for subsequent steps
          IMAGE_ID_LOWER=$(echo "${{ env.IMAGE_ID_RAW }}" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_ID=${IMAGE_ID_LOWER}" >> $GITHUB_ENV

      - name: Set up QEMU
        # Required for Docker Buildx to emulate foreign architectures (e.g., to run the final scratch image steps,
        # though minimal for scratch, or for any RUN commands in foreign arch layers).
        # Its impact on Rust compilation speed is minimal with the cross-compilation strategy.
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all # Enable emulation for all common platforms

      - name: Set up Docker Buildx
        # This sets up a Buildx builder instance capable of multi-architecture builds.
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        # Authenticates with GHCR using the GitHub Token, allowing pushing images.
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Docker metadata
        # This action automatically generates standard Docker image tags and labels.
        id: meta
        uses: docker/metadata-action@v5
        with:
          # Use the now lowercased IMAGE_ID from the environment for generating tags
          images: ${{ env.IMAGE_ID }}
          tags: |
            type=raw,value=${{ env.APP_NAME }}-${{ github.sha }} # Tag with app name and commit SHA
            type=ref,event=branch,enable=${{ github.ref == 'refs/heads/main' }},value=latest # 'main' branch gets 'latest' tag
            type=ref,event=pr,suffix=-pr{{ github.event.pull_request.number }} # Pull requests get a tag like 'my-app-pr123'
          labels: |
            org.opencontainers.image.source=${{ github.event.repository.html_url }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.url=${{ github.event.repository.html_url }}

      - name: Build and push container image
        # This action performs the multi-architecture build and pushes the images.
        uses: docker/build-push-action@v5
        with:
          context: . # The Dockerfile is expected in the root of the repository
          platforms: linux/amd64,linux/arm64 # Specify target architectures to build for
          push: true # Push the built images and manifest list to the registry
          tags: ${{ steps.meta.outputs.tags }} # Use the generated tags
          labels: ${{ steps.meta.outputs.labels }} # Use the generated labels
          # Docker Buildx caching: Crucial for faster subsequent builds.
          # It pulls cache layers from the registry and pushes new ones back.
          # Use the lowercased IMAGE_ID here to satisfy GHCR's requirements.
          cache-from: type=registry,ref=${{ env.IMAGE_ID }}:buildcache
          cache-to: type=registry,ref=${{ env.IMAGE_ID }}:buildcache,mode=max
          target: final_image # Instructs Buildx to build the 'final_image' stage from your Dockerfile
          # REMOVED: build-args for RUST_TOOLCHAIN_TARGET, as TARGETPLATFORM handles it in Dockerfile
