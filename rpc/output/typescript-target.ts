import type { Type } from 'ts-morph';
import { SyntaxKind } from 'ts-morph';
import * as ts from 'typescript';
import { capitalizeFirstLetter, getMembers } from '../util';
import { Target, type Argument } from './target';

export class TypeScriptTarget extends Target {
	constructor() {
		super();
		this.imports.push(
			`import type { ReaperApiClient } from "../api";`,
			`import { GetStateCommand, RunScriptCommand, SetOperationCommand, SetStateCommand } from "./commands";`,
			`import { SectionKeys } from "./reaper-state";`
		);
	}

	protected override renderTypeDefinitions(): string[] {
		const typeDefs: string[][] = [];
		typeDefs.push([`export type ChunkSet = string[];`]);
		for (const type of Object.values(this.types)) {
			const typeLines: string[] = [];
			let trueType: Type<ts.Type> | undefined = type;
			if (type.isArray()) {
				trueType = type.getArrayElementType();
			}

			if (trueType?.isClassOrInterface()) {
				const members = getMembers(trueType);
				typeLines.push(`export interface ${trueType.getText()} {`);

				// Get properties from the interface declaration
				for (const node of Object.values(members)) {
					const propSig = node.asKindOrThrow(SyntaxKind.PropertySignature);
					const propName = propSig.getName();
					const typeNode = propSig.getTypeNode();
					const propType = typeNode ? typeNode.getText() : 'any';
					typeLines.push(`\t${propName}: ${propType};`);
				}
				typeLines.push(`}`);
				typeDefs.push(typeLines);
			}
		}
		const lines = typeDefs.map(definition => definition.join('\n'));

		return lines;
	}


	override getOutputPathParts(): string[] {
		return ['..', 'frontend', 'src', 'lib', 'api', 'reaper-backend', 'reaper-rpc-client.svelte.ts'];
	}

	override renderHeader(): string[] {
		const lines = [`// Generated by ts-morph script. Do not edit manually!`];
		return lines;
	}

	override renderClassDefinition(): string[] {
		const constructorArgs = [
			`private readonly apiClient: ReaperApiClient`
		]
		return [
			`export class ReaperRpcClient {`,
			`\tconstructor(${constructorArgs.join(', ')}) { }`,
		];
	}

	override renderClassEnd(): string[] {
		return [`}`];
	}

	override renderOperations(): string[] {
		let code: string[] = [];
		let operationLines: string[][] = [];
		for (const { name, inputs, outputs } of this.operations) {
			operationLines.push(this.renderOperation(name, inputs, outputs));
		}
		code.push(operationLines.map((lines) => lines.join('\n')).join('\n\n'));
		return code;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[]): string[] {
		const operationLines: string[] = [];
		let outputsStr;
		if (outputs.length === 0) {
			outputsStr = 'void';
		} else if (outputs.length === 1) {
			outputsStr = outputs[0]!.type.getText();
		} else {
			outputsStr = `{ ${outputs.map((o) => `${o.name}: ${o.type.getText()}`).join(', ')} }`;
		}
		operationLines.push(
			`public async ${name}(${inputs
				.map((input) => `${input.name}: ${input.type.getText()}`)
				.join(', ')
			}): Promise<${outputsStr}> {`
		);
		operationLines.push(`\tconst commands = [`);
		for (const { name, type } of inputs) {
			if (type.getText() === 'ChunkSet') {
				operationLines.push(`\t\tnew SetStateCommand(SectionKeys.ReaperSetlist, "${name}_length", ${name}.length.toString()),`);
				operationLines.push(`\t\t...${name}.map((chunk, index) => new SetStateCommand(SectionKeys.ReaperSetlist, \`chunk_\${index}\`, chunk)),`);
			} else {
				operationLines.push(`\t\tnew SetStateCommand(SectionKeys.ReaperSetlist, "${name}", ${name}),`);
			}
		}

		operationLines.push(`\t\tnew SetOperationCommand("${name}"),`);
		operationLines.push(`\t\tnew RunScriptCommand(),`);

		for (const { name, type } of outputs) {
			operationLines.push(`\t\tnew GetStateCommand(SectionKeys.ReaperSetlist, "${name}"),`);
		}

		operationLines.push(`\t] as const;`)

		if (outputs.length > 0) {
			const inputReturns = inputs.map((input) => `_set${capitalizeFirstLetter(input.name)}`);
			const setOperationReturn = `_setOperation`;
			const runScriptReturn = '_runScript';
			const outputReturns = outputs.map((output) => `${output.name}Raw`);
			const allReturns = [...inputReturns, setOperationReturn, runScriptReturn, ...outputReturns];

			operationLines.push(`\tconst [${allReturns.join(', ')}] = await this.apiClient.executeCommands(commands); `);
		} else {
			operationLines.push(`\tawait this.apiClient.executeCommands(commands); `);
		}

		for (const output of outputs) {
			operationLines.push(`\tif (${output.name}Raw === undefined) {`);
			operationLines.push(`\t\tthrow new Error("Failed to retrieve ${output.name}. Please check the script configuration.");`);
			operationLines.push(`\t}`);

			if (output.type.isArray() || output.type.isClassOrInterface()) {
				operationLines.push(`\tconst ${output.name} = JSON.parse(${output.name}Raw) as ${output.type.getText()}; `);
			} else if (output.type.isString()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Raw; `);
			} else if (output.type.isNumber()) {
				operationLines.push(`\tconst ${output.name} = parseFloat(${output.name}Raw); `);
			} else if (output.type.isBoolean()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Raw === 'true'; `);
			} else {
				throw new Error(`Unsupported output type: ${output.type.getText()}`);
			}

		}

		if (outputs.length === 1) {
			operationLines.push(`\treturn ${outputs[0]!.name}; `);
		} else if (outputs.length > 1) {
			operationLines.push(`\treturn { ${outputs.map((o) => o.name).join(', ')} }; `);
		}
		operationLines.push(`} `);
		return operationLines.map(x => `\t${x} `);
	}
}
