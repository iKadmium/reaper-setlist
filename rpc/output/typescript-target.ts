import { Target, type Argument } from './target';

export class TypeScriptTarget extends Target {
	constructor() {
		super();
		this.imports.push(
			`import { configuration } from "$lib/stores/configuration.svelte";`,
			`import type { ReaperCommand, ReaperApiClient } from "../api";`,
			`import { ReaperScriptCommandBuilder } from './reaper-script-command-builder';`
		);
	}

	override getOutputPathParts(): string[] {
		return ['..', 'frontend', 'src', 'lib', 'api', 'reaper-backend', 'reaper-rpc-client.svelte.ts'];
	}

	override renderHeader(): string[] {
		const lines = [`// Generated by ts-morph script. Do not edit manually!`];
		return lines;
	}

	override renderClassDefinition(): string[] {
		const constructorArgs = [
			`private readonly commandBuilder: ReaperScriptCommandBuilder`,
			`private readonly apiClient: ReaperApiClient`
		]
		return [
			`export class ReaperRpcClient {`,
			`\tconstructor(`,
			`\t\t${constructorArgs.join(', \n\t\t')}`,
			`\t) { }`,
			``,
			`\tprivate async getScriptActionId(): Promise<ReaperCommand> {`,
			`\t\tawait configuration.ensureInitialized();`,
			`\t\tconst actionId = configuration.scriptActionId;`,
			`\t\tif (!actionId) {`,
			`\t\t\tthrow new Error("Script action ID is not set. Please configure it in the settings.");`,
			`\t\t}`,
			`\treturn actionId as ReaperCommand;`,
			`\t}`,
		];
	}

	override renderClassEnd(): string[] {
		return [`}`];
	}

	override renderOperations(): string[] {
		let code: string[] = [];
		let operationLines: string[][] = [];
		for (const { name, inputs, outputs } of this.operations) {
			operationLines.push(this.renderOperation(name, inputs, outputs));
		}
		code.push(operationLines.map((lines) => lines.join('\n')).join('\n\n'));
		return code;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[]): string[] {
		const operationLines: string[] = [];
		let outputsStr;
		if (outputs.length === 0) {
			outputsStr = 'void';
		} else if (outputs.length === 1) {
			outputsStr = outputs[0]!.type.getText();
		} else {
			outputsStr = `{ ${outputs.map((o) => `${o.name}: ${o.type.getText()}`).join(', ')} }`;
		}
		operationLines.push(
			`public async ${name}(${inputs
				.map((input) => `${input.name}: ${input.type.getText()}`)
				.join(', ')
			}): Promise<${outputsStr}> {`
		);
		operationLines.push(`\tconst actionId = await this.getScriptActionId();`);
		operationLines.push(`\tconst commands: ReaperCommand[] = []; `);
		for (const { name, type } of inputs) {
			operationLines.push(`\tcommands.push(this.commandBuilder.setExtState("${name}", ${name}, true)); `);
		}

		operationLines.push(`\tcommands.push(this.commandBuilder.setOperation("${name}")); `);
		operationLines.push(`\tcommands.push(actionId); `);

		for (const { name, type } of outputs) {
			operationLines.push(`\tcommands.push(this.commandBuilder.getExtState("${name}")); `);
		}

		if (outputs.length === 0) {
			operationLines.push(`\tawait this.apiClient.sendCommands(commands);`);
		} else {
			operationLines.push(`\tconst result = await this.apiClient.sendCommands(commands); `);
		}

		for (let i = 0; i < outputs.length; i++) {
			const output = outputs[i]!;
			const resultIndex = i;
			operationLines.push(`\tconst ${output.name}Raw = result[${resultIndex}];`);
			operationLines.push(`\tconst ${output.name}Parts = ${output.name}Raw.split('\\t');`);
			if (output.type.isArray()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Parts[3].split(',');`);
			} else if (output.type.isString()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Parts[3];`);
			} else if (output.type.isNumber()) {
				operationLines.push(`\tconst ${output.name} = parseFloat(${output.name}Parts[3]);`);
			} else {
				throw new Error(`Unsupported output type: ${output.type.getText()}`);
			}
		}

		if (outputs.length === 1) {
			operationLines.push(`\treturn ${outputs[0]!.name};`);
		} else if (outputs.length > 1) {
			operationLines.push(`\treturn { ${outputs.map((o) => o.name).join(', ')} }; `);
		}
		operationLines.push(`}`);
		return operationLines.map(x => `\t${x}`);
	}
}
