import { Target, type Argument, type OperationOptions } from './target';

export class TypeScriptTarget extends Target {
	constructor() {
		super();
		this.imports.push(
			`import type { ReaperCommand } from "../api";`,
			`import type { ReaperScriptCommandBuilder } from './reaper-script-command-builder';`
		);
	}

	override getOutputPathParts(): string[] {
		return ['..', 'frontend', 'src', 'lib', 'api', 'reaper-backend', 'rpc_definitions.ts'];
	}

	override renderHeader(): string[] {
		const lines = [`// Generated by ts-morph script. Do not edit manually!`];
		return lines;
	}

	override renderClassDefinition(): string[] {
		return [
			`export class ReaperRpc {`,
			`\tconstructor(private readonly commandBuilder: ReaperScriptCommandBuilder) {}`,
			``
		];
	}

	override renderClassEnd(): string[] {
		return [`}`];
	}

	override renderImports(): string[] {
		return [`import type { ReaperCommand } from "../api";`];
	}

	override renderOperations(): string[] {
		let code: string[] = [];
		let operationLines: string[][] = [];
		for (const { name, inputs, outputs } of this.operations) {
			operationLines.push(this.renderOperation(name, inputs, outputs));
		}
		code.push(operationLines.map((lines) => lines.join('\n')).join('\n\n'));
		return code;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[]): string[] {
		const operationLines: string[] = [];
		let outputsStr;
		if (outputs.length === 0) {
			outputsStr = 'void';
		} else {
			outputsStr = `{ ${outputs.map((o) => `${o.name}: ${o.type.getText()}`).join(', ')} }`;
		}
		operationLines.push(
			`export async function ${name}(${inputs
				.map((input) => input.name)
				.join(', ')}): Promise<${outputsStr}> {`
		);
		operationLines.push(`\tconst commands: ReaperCommand[] = [];`);
		for (const { name, type } of inputs) {
			operationLines.push(`\tcommands.push(this.commandBuilder.setExtState("${name}"));`);
		}

		if (outputs.length === 0) {
			operationLines.push(`\tawait ${name}(${inputs.map((input) => input.name).join(', ')});`);
			operationLines.push(`}`);
		} else {
			operationLines.push(
				`\tconst result = await ${name}(${inputs.map((input) => input.name).join(', ')});`
			);
			operationLines.push(`\treturn { ${outputs.map((o) => o.name + ': result').join(', ')} };`);
			operationLines.push(`}`);
		}
		return operationLines;
	}
}
