import * as ts from 'typescript';
import type { Type } from 'ts-morph';
import { SyntaxKind } from 'ts-morph';
import { Target, type Argument } from './target';
import { getMembers } from '../util';

export class TypeScriptTarget extends Target {
	constructor() {
		super();
		this.imports.push(
			`import { configuration } from "$lib/stores/configuration.svelte";`,
			`import type { ReaperCommand, ReaperApiClient } from "../api";`,
			`import { ReaperScriptCommandBuilder } from './reaper-script-command-builder';`
		);
	}

	protected override renderTypeDefinitions(): string[] {
		const typeDefs: string[][] = [];
		for (const type of Object.values(this.types)) {
			const typeLines: string[] = [];
			let trueType: Type<ts.Type> | undefined = type;
			if (type.isArray()) {
				trueType = type.getArrayElementType();
			}

			if (trueType?.isClassOrInterface()) {
				const members = getMembers(trueType);
				typeLines.push(`export interface ${trueType.getText()} {`);

				// Get properties from the interface declaration
				for (const node of Object.values(members)) {
					const propSig = node.asKindOrThrow(SyntaxKind.PropertySignature);
					const propName = propSig.getName();
					const typeNode = propSig.getTypeNode();
					const propType = typeNode ? typeNode.getText() : 'any';
					typeLines.push(`\t${propName}: ${propType};`);
				}
				typeLines.push(`}`);
			}

			typeDefs.push(typeLines);
		}
		const lines = typeDefs.map(definition => definition.join('\n'));

		return lines;
	}


	override getOutputPathParts(): string[] {
		return ['..', 'frontend', 'src', 'lib', 'api', 'reaper-backend', 'reaper-rpc-client.svelte.ts'];
	}

	override renderHeader(): string[] {
		const lines = [`// Generated by ts-morph script. Do not edit manually!`];
		return lines;
	}

	override renderClassDefinition(): string[] {
		const constructorArgs = [
			`private readonly commandBuilder: ReaperScriptCommandBuilder`,
			`private readonly apiClient: ReaperApiClient`
		]
		return [
			`export class ReaperRpcClient {`,
			`\tconstructor(`,
			`\t\t${constructorArgs.join(', \n\t\t')}`,
			`\t) { }`,
			``,
			`\tprivate async getScriptActionId(): Promise<ReaperCommand> {`,
			`\t\tawait configuration.ensureInitialized();`,
			`\t\tconst actionId = configuration.scriptActionId;`,
			`\t\tif (!actionId) {`,
			`\t\t\tthrow new Error("Script action ID is not set. Please configure it in the settings.");`,
			`\t\t}`,
			`\t\treturn actionId as ReaperCommand;`,
			`\t}`,
		];
	}

	override renderClassEnd(): string[] {
		return [`}`];
	}

	override renderOperations(): string[] {
		let code: string[] = [];
		let operationLines: string[][] = [];
		for (const { name, inputs, outputs } of this.operations) {
			operationLines.push(this.renderOperation(name, inputs, outputs));
		}
		code.push(operationLines.map((lines) => lines.join('\n')).join('\n\n'));
		return code;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[]): string[] {
		const operationLines: string[] = [];
		let outputsStr;
		if (outputs.length === 0) {
			outputsStr = 'void';
		} else if (outputs.length === 1) {
			outputsStr = outputs[0]!.type.getText();
		} else {
			outputsStr = `{ ${outputs.map((o) => `${o.name}: ${o.type.getText()}`).join(', ')} }`;
		}
		operationLines.push(
			`public async ${name}(${inputs
				.map((input) => `${input.name}: ${input.type.getText()}`)
				.join(', ')
			}): Promise<${outputsStr}> {`
		);
		operationLines.push(`\tconst actionId = await this.getScriptActionId();`);
		operationLines.push(`\tconst commands: ReaperCommand[] = []; `);
		for (const { name, type } of inputs) {
			operationLines.push(`\tcommands.push(this.commandBuilder.setExtState("${name}", ${name}, true)); `);
		}

		operationLines.push(`\tcommands.push(this.commandBuilder.setOperation("${name}")); `);
		operationLines.push(`\tcommands.push(actionId); `);

		for (const { name, type } of outputs) {
			operationLines.push(`\tcommands.push(this.commandBuilder.getExtState("${name}")); `);
		}

		if (outputs.length === 0) {
			operationLines.push(`\tawait this.apiClient.sendCommands(commands);`);
		} else {
			operationLines.push(`\tconst result = await this.apiClient.sendCommands(commands); `);
		}

		for (let i = 0; i < outputs.length; i++) {
			const output = outputs[i]!;
			const resultIndex = i;
			operationLines.push(`\tconst ${output.name}Raw = result[${resultIndex}];`);
			operationLines.push(`\tconst ${output.name}Parts = ${output.name}Raw.split('\\t');`);
			if (output.type.isString()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Parts[3];`);
			} else if (output.type.isNumber()) {
				operationLines.push(`\tconst ${output.name} = parseFloat(${output.name}Parts[3]);`);
			} else {
				operationLines.push(`\tconst ${output.name} = JSON.parse(${output.name}Parts[3]);`);
			}
		}

		if (outputs.length === 1) {
			operationLines.push(`\treturn ${outputs[0]!.name};`);
		} else if (outputs.length > 1) {
			operationLines.push(`\treturn { ${outputs.map((o) => o.name).join(', ')} }; `);
		}
		operationLines.push(`}`);
		return operationLines.map(x => `\t${x}`);
	}
}
