import type { Type, TypeParameter } from 'ts-morph';
import { SyntaxKind } from 'ts-morph';
import * as ts from 'typescript';
import { capitalizeFirstLetter, getMembers } from '../util';
import { Target, type Argument } from './target';

export class TypeScriptTarget extends Target {
	constructor() {
		super();
		this.imports.push(
			`import { GetStateCommand, RunScriptCommand, SetOperationCommand, SetStateCommand } from "./commands";`,
			`import type { ReaperApiClient } from "./reaper-api";`,
			`import { SectionKeys } from "./reaper-state";`
		);
	}

	protected override renderTypeDefinitions(): string[] {
		const typeDefs: string[][] = [];
		typeDefs.push([`export type Chunkable<T> = T;`]);
		for (const type of Object.values(this.types)) {
			const typeLines: string[] = [];
			let trueType: Type<ts.Type> | undefined = type;
			if (type.isArray()) {
				trueType = type.getArrayElementType();
			}

			if (trueType?.isClassOrInterface()) {
				const members = getMembers(trueType);
				typeLines.push(`export interface ${trueType.getText()} {`);

				// Get properties from the interface declaration
				for (const node of Object.values(members)) {
					const propSig = node.asKindOrThrow(SyntaxKind.PropertySignature);
					const propName = propSig.getName();
					const typeNode = propSig.getTypeNode();
					const propType = typeNode ? typeNode.getText() : 'any';
					typeLines.push(`\t${propName}: ${propType};`);
				}
				typeLines.push(`}`);
				typeDefs.push(typeLines);
			}
		}
		const lines = typeDefs.map(definition => definition.join('\n'));

		return lines;
	}


	override getOutputPathParts(): string[] {
		return ['..', 'frontend', 'src', 'lib', 'api', 'reaper-backend', 'reaper-rpc-client.svelte.ts'];
	}

	override renderHeader(): string[] {
		const lines = [`// Generated by ts-morph script. Do not edit manually!`];
		return lines;
	}

	override renderClassDefinition(): string[] {
		const constructorArgs = [
			`private readonly apiClient: ReaperApiClient`
		]
		return [
			`export class ReaperRpcClient {`,
			`\tconstructor(${constructorArgs.join(', ')}) { }`,
			``,
			`\tprivate getChunkCommands<T>(name: string, item: Chunkable<T>): SetStateCommand[] {`,
			`\t\tconst chunks: string[] = [];`,
			`\t\tconst itemString = JSON.stringify(item);`,
			`\t\tconst chunkSize = 500;`,
			`\t\tfor (let i = 0; i < itemString.length; i += chunkSize) {`,
			`\t\t\tchunks.push(itemString.slice(i, i + chunkSize));`,
			`\t\t}`,
			``,
			`\t\tconst commands: SetStateCommand[] = [];`,
			`\t\tcommands.push(new SetStateCommand(SectionKeys.ReaperSetlist, ` + '`${name}_length`' + `, chunks.length.toString()));`,
			`\t\tfor (let index = 0; index < chunks.length; index++) {`,
			`\t\t\tcommands.push(new SetStateCommand(SectionKeys.ReaperSetlist, ` + '`${name}_${index}`' + `, chunks[index]));`,
			`\t\t}`,
			`\t\treturn commands;`,
			`\t}`,
		];
	}

	override renderClassEnd(): string[] {
		return [`}`];
	}

	override renderOperations(): string[] {
		let code: string[] = [];
		let operationLines: string[][] = [];
		for (const { name, inputs, outputs, typeArgs } of this.operations) {
			operationLines.push(this.renderOperation(name, inputs, outputs, typeArgs));
		}
		code.push(operationLines.map((lines) => lines.join('\n')).join('\n\n'));
		return code;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[], typeParams: TypeParameter[]): string[] {
		const operationLines: string[] = [];
		let outputsStr;
		if (outputs.length === 0) {
			outputsStr = 'void';
		} else if (outputs.length === 1) {
			outputsStr = outputs[0]!.type.getText();
		} else {
			outputsStr = `{ ${outputs.map((o) => `${o.name}: ${o.type.getText()}`).join(', ')} }`;
		}
		const typeParamsStr = typeParams.length > 0
			? `<${typeParams.map((tp) => tp.getText()).join(', ')}>`
			: '';
		operationLines.push(
			`public async ${name}${typeParamsStr}(${inputs
				.map((input) => `${input.name}: ${input.type.getText()}`)
				.join(', ')
			}): Promise<${outputsStr}> {`
		);
		operationLines.push(`\tconst commands = [`);
		for (const { name, type } of inputs) {
			if (type.getText() === 'Chunkable<T>') {
				operationLines.push(`\t\t...this.getChunkCommands("${name}", ${name}),`);
			} else {
				operationLines.push(`\t\tnew SetStateCommand(SectionKeys.ReaperSetlist, "${name}", ${name}),`);
			}
		}

		operationLines.push(`\t\tnew SetOperationCommand("${name}"),`);
		operationLines.push(`\t\tnew RunScriptCommand(),`);

		for (const { name, type } of outputs) {
			operationLines.push(`\t\tnew GetStateCommand(SectionKeys.ReaperSetlist, "${name}"),`);
		}

		operationLines.push(`\t] as const;`)

		if (outputs.length > 0) {
			const inputReturns = inputs.map((input) => `_set${capitalizeFirstLetter(input.name)}`);
			const setOperationReturn = `_setOperation`;
			const runScriptReturn = '_runScript';
			const outputReturns = outputs.map((output) => `${output.name}Raw`);
			const allReturns = [...inputReturns, setOperationReturn, runScriptReturn, ...outputReturns];

			operationLines.push(`\tconst [${allReturns.join(', ')}] = await this.apiClient.executeCommands(commands); `);
		} else {
			operationLines.push(`\tawait this.apiClient.executeCommands(commands); `);
		}

		for (const output of outputs) {
			operationLines.push(`\tif (${output.name}Raw === undefined) {`);
			operationLines.push(`\t\tthrow new Error("Failed to retrieve ${output.name}. Please check the script configuration.");`);
			operationLines.push(`\t}`);

			if (output.type.isArray() || output.type.isClassOrInterface()) {
				operationLines.push(`\tconst ${output.name} = JSON.parse(${output.name}Raw) as ${output.type.getText()}; `);
			} else if (output.type.isString()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Raw; `);
			} else if (output.type.isNumber()) {
				operationLines.push(`\tconst ${output.name} = parseFloat(${output.name}Raw); `);
			} else if (output.type.isBoolean()) {
				operationLines.push(`\tconst ${output.name} = ${output.name}Raw === 'true'; `);
			} else {
				throw new Error(`Unsupported output type: ${output.type.getText()}`);
			}
		}

		if (outputs.length === 1) {
			operationLines.push(`\treturn ${outputs[0]!.name}; `);
		} else if (outputs.length > 1) {
			operationLines.push(`\treturn { ${outputs.map((o) => o.name).join(', ')} }; `);
		}
		operationLines.push(`} `);
		return operationLines.map(x => `\t${x} `);
	}
}
