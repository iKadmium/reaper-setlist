import { SyntaxKind, type ts, type Type } from 'ts-morph';
import { Target } from './target';
import type { Argument, OperationOptions } from './target';
import { getMembers } from '../util';

// Helper function to convert camelCase to snake_case
function camelToSnakeCase(str: string): string {
	return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

// Helper function to capitalise first letter
function capitalise(str: string): string {
	return str.charAt(0).toUpperCase() + str.slice(1);
}

export class LuaTarget extends Target {
	constructor() {
		super();
		this.imports.push(`local Globals = require "globals"`);
		this.imports.push(`local json = require "json"`);
	}

	override getOutputPathParts(): string[] {
		return ['..', 'lua', 'operations_registry.lua'];
	}

	override renderHeader(): string[] {
		return [
			`-- Generated by ts-morph script. Do not edit manually!`,
			``,
			`---@param func function`,
			`---@return function`,
			`local function safe_operation(func)`,
			`    return function()`,
			`        local success, err = pcall(func)`,
			`        if not success then`,
			`            reaper.ShowConsoleMsg("Error: " .. tostring(err) .. "\\n")`,
			`        end`,
			`    end`,
			`end`
		];
	}

	protected override renderTypeDefinitions(): string[] {
		const typeDefs: string[][] = [];
		for (const type of Object.values(this.types)) {
			const typeLines: string[] = [];
			let trueType: Type<ts.Type> | undefined = type;
			if (type.isArray()) {
				trueType = type.getArrayElementType();
			}

			if (trueType?.isClassOrInterface()) {
				const members = getMembers(trueType);
				typeLines.push(`---@class ${trueType.getText()}`);

				// Get properties from the interface declaration
				for (const node of Object.values(members)) {
					const propSig = node.asKindOrThrow(SyntaxKind.PropertySignature);
					const propName = propSig.getName();
					const typeNode = propSig.getTypeNode();
					const propType = typeNode ? typeNode.getText() : 'any';
					typeLines.push(`---@field ${propName} ${propType}`);
				}
				typeDefs.push(typeLines);
			}
		}
		const lines = typeDefs.map((definition) => definition.join('\n'));

		return lines;
	}

	override addOperation(options: OperationOptions): void {
		super.addOperation(options);
		this.imports.push(
			`local ${capitalise(options.name)} = require "operations/${camelToSnakeCase(options.name)}"`
		);
	}

	override renderOperations(): string[] {
		let lines: string[] = [];
		lines.push(`local Operations = {`);

		const allOperations: string[][] = [];
		for (const { name, inputs, outputs } of this.operations) {
			const operationLines = this.renderOperation(name, inputs, outputs);
			allOperations.push(operationLines);
		}
		lines.push(allOperations.map((operationLines) => operationLines.join('\n')).join('\n\n'));

		lines.push(`}`);
		lines.push(``);
		lines.push(`return Operations`);

		return lines;
	}

	private getInputChecker(name: string): string[] {
		const lines: string[] = [];
		lines.push(`\t\tlocal ${name} = reaper.GetExtState(Globals.SECTION, "${name}")`);
		lines.push(`\t\tif not ${name} or ${name} == "" then`);
		lines.push(`\t\t\terror("Missing required parameter: ${name}")`);
		lines.push(`\t\tend`);
		return lines;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[]): string[] {
		const operationLines: string[] = [];
		const functionName = name.charAt(0).toUpperCase() + name.slice(1);
		operationLines.push(`\t["${name}"] = safe_operation(function()`);
		for (const { name: name, type } of inputs) {
			if (type.getText() === 'Chunkable<T>') {
				operationLines.push(...this.getInputChecker(`${name}_length`));
				operationLines.push(``);
				operationLines.push(`\t\tlocal ${name} = {}`);
				operationLines.push(`\t\tfor i = 0, (tonumber(${name}_length) - 1) do`);
				operationLines.push(
					`\t\t\tlocal chunk = reaper.GetExtState(Globals.SECTION, "${name}_" .. i)`
				);
				operationLines.push(`\t\t\tif chunk and chunk ~= "" then`);
				operationLines.push(`\t\t\t\t${name}[i + 1] = chunk`);
				operationLines.push(`\t\t\telse`);
				operationLines.push(`\t\t\t\terror("Missing chunk for ${name} at index " .. i)`);
				operationLines.push(`\t\t\tend`);
				operationLines.push(`\t\tend`);
			} else {
				operationLines.push(...this.getInputChecker(name));
			}
			operationLines.push('');
		}
		const argsList = inputs.map((input) => input.name).join(', ');
		if (outputs.length === 0) {
			operationLines.push(`\t\t${functionName}(${argsList})`);
			operationLines.push('');
		} else {
			operationLines.push(
				`\t\tlocal ${outputs
					.map((output) => output.name)
					.join(', ')} = ${functionName}(${argsList})`
			);
			operationLines.push('');
			for (const { name: outputName, type } of outputs) {
				operationLines.push(`\t\tif not ${outputName} or ${outputName} == '' then`);
				operationLines.push(
					`\t\t\terror("Operation ${name} failed to return required output: ${outputName}")`
				);
				operationLines.push(`\t\tend`);
				operationLines.push('');
				if (type.isNumber()) {
					operationLines.push(
						`\t\treaper.SetExtState(Globals.SECTION, "${outputName}", tostring(${outputName}), true)`
					);
				} else if (type.isString()) {
					operationLines.push(
						`\t\treaper.SetExtState(Globals.SECTION, "${outputName}", ${outputName}, true)`
					);
				} else {
					operationLines.push(
						`\t\treaper.SetExtState(Globals.SECTION, "${outputName}", json.encode(${outputName}), true)`
					);
				}
			}
		}
		if (inputs.length > 0) {
			for (const { name, type } of inputs) {
				if (type.getText() === 'ChunkSet') {
					operationLines.push(`\t\treaper.DeleteExtState(Globals.SECTION, "${name}_length", true)`);
					operationLines.push(`\t\tfor i = 0, tonumber(${name}_length) do`);
					operationLines.push(
						`\t\t\treaper.DeleteExtState(Globals.SECTION, "${name}_" .. i, true)`
					);
					operationLines.push(`\t\tend`);
				} else {
					operationLines.push(`\t\treaper.DeleteExtState(Globals.SECTION, "${name}", true)`);
				}
			}
		}
		operationLines.push(`\tend),`);
		return operationLines;
	}
}
