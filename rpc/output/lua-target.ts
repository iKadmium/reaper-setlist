import { Target } from './target';
import type { Argument, OperationOptions } from './target';

// Helper function to convert camelCase to snake_case
function camelToSnakeCase(str: string): string {
	return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

// Helper function to capitalise first letter
function capitalise(str: string): string {
	return str.charAt(0).toUpperCase() + str.slice(1);
}

export class LuaTarget extends Target {
	override getOutputPathParts(): string[] {
		return ['..', 'lua', 'operations.lua'];
	}

	override renderHeader(): string[] {
		return [
			`-- Generated by ts-morph script. Do not edit manually!`,
			``,
			`---@param func function`,
			`---@return function`,
			`local function safe_operation(func)`,
			`    return function()`,
			`        local success, err = pcall(func)`,
			`        if not success then`,
			`            reaper.ShowConsoleMsg("Error: " .. tostring(err) .. "\\n")`,
			`        end`,
			`    end`,
			`end`
		];
	}

	override renderImports(): string[] {
		const lines: string[] = [];
		lines.push(`local globals = require "globals"`);
		for (const imp of this.imports) {
			lines.push(imp);
		}
		return lines;
	}

	override addOperation(options: OperationOptions): void {
		super.addOperation(options);
		this.imports.push(
			`local ${capitalise(options.name)} = require "operations/${camelToSnakeCase(options.name)}"`
		);
	}

	override renderOperations(): string[] {
		let lines: string[] = [];
		lines.push(`local Operations = {`);

		const allOperations: string[][] = [];
		for (const { name, inputs, outputs } of this.operations) {
			const operationLines = this.renderOperation(name, inputs, outputs);
			allOperations.push(operationLines);
		}
		lines.push(allOperations.map((operationLines) => operationLines.join('\n')).join('\n\n'));

		lines.push(`}`);
		lines.push(``);
		lines.push(`return Operations`);

		return lines;
	}

	private renderOperation(name: string, inputs: Argument[], outputs: Argument[]): string[] {
		const operationLines: string[] = [];
		const functionName = name.charAt(0).toUpperCase() + name.slice(1);
		operationLines.push(`\t["${name}"] = safe_operation(function()`);
		if (inputs.length > 0) {
			for (const { name: name, type } of inputs) {
				operationLines.push(`\t\tlocal ${name} = reaper.GetExtState(globals.SECTION, "${name}")`);
				operationLines.push(`\t\tif not ${name} or ${name} == "" then`);
				operationLines.push(`\t\t\terror("Missing required parameter: ${name}")`);
				operationLines.push(`\t\tend`);
				operationLines.push('');
			}
		}
		const argsList = inputs.map((input) => input.name).join(', ');
		if (outputs.length === 0) {
			operationLines.push(`\t\t${functionName}(${argsList})`);
			operationLines.push('');
		} else {
			operationLines.push(
				`\t\tlocal ${outputs
					.map((output) => output.name)
					.join(', ')} = ${functionName}(${argsList})`
			);
			operationLines.push('');
			for (const { name, type } of outputs) {
				operationLines.push(`\t\tif not ${name} or ${name} == '' then`);
				operationLines.push(
					`\t\t\terror("Operation ${name} failed to return required output: ${name}")`
				);
				operationLines.push(`\t\tend`);
				operationLines.push('');
				operationLines.push(`\t\treaper.SetExtState(globals.SECTION, "${name}", ${name}, true)`);
			}
		}
		if (inputs.length > 0) {
			for (const param of inputs) {
				operationLines.push(`\t\treaper.DeleteExtState(globals.SECTION, "${param.name}", true)`);
			}
		}
		operationLines.push(`\tend),`);
		return operationLines;
	}
}
