// scripts/generate_lua_rpc.ts (Node.js script)
import * as fs from 'node:fs';
import * as path from 'node:path';
import { Project } from 'ts-morph';
import { indent } from './util';

const project = new Project({
    tsConfigFilePath: "tsconfig.json", // Point to your tsconfig for type resolution
});

const sourceFile = project.getSourceFileOrThrow("./script-operations.ts");
const scriptOperationsInterface = sourceFile.getInterfaceOrThrow("ScriptOperations");

// Helper function to convert camelCase to snake_case
function camelToSnakeCase(str: string): string {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
}

// Helper function to capitalize first letter
function capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

let luaRpcCode = `-- Generated by ts-morph script. Do not edit manually!

local globals = require "globals"

---@param func function
---@return function
local function safe_operation(func)
    return function()
        local success, err = pcall(func)
        if not success then
            reaper.ShowConsoleMsg("Error: " .. tostring(err) .. "\\n")
        end
    end
end

`;

// Generate imports and operations based on the TypeScript interface
const imports = new Set<string>();
const operations: string[] = [];

for (const prop of scriptOperationsInterface.getProperties()) {
    const operationName = prop.getName();
    const propType = prop.getType();

    if (propType.getCallSignatures().length > 0) {
        const signature = propType.getCallSignatures()[0];
        if (!signature) continue;

        const parameters = signature.getParameters();
        const returnType = signature.getReturnType();

        // Convert camelCase operation name to snake_case file name
        const fileName = camelToSnakeCase(operationName);
        const functionName = capitalize(operationName);

        // Add to imports
        imports.add(`local ${functionName} = require "${fileName}"`);

        // Start building the operation
        let operationLines: string[] = [];
        operationLines.push(`\t["${operationName}"] = safe_operation(function()`);

        // Get parameters from state
        const paramNames: string[] = [];
        for (const param of parameters) {
            const paramName = param.getName();
            const paramType = param.getTypeAtLocation(sourceFile);
            paramNames.push(paramName);

            operationLines.push(`\t\tlocal ${paramName} = reaper.GetExtState(globals.SECTION, "${paramName}")`);

            // Add validation for required parameters
            if (!paramType.isUnion() || !paramType.getUnionTypes().some(t => t.isUndefined())) {
                operationLines.push(`\t\tif not ${paramName} or ${paramName} == "" then`);
                operationLines.push(`\t\t\terror("Missing required parameter: ${paramName}")`);
                operationLines.push(`\t\tend`);
                operationLines.push('');
            }
        }

        // Call the function
        const argsList = paramNames.join(", ");
        if (returnType.isVoid() || returnType.getText(sourceFile) === "Promise<void>") {
            // No return value
            operationLines.push(`\t\t${functionName}(${argsList})`);
        } else {
            // Has return value - capture it and save to state
            operationLines.push(`\t\tlocal result = ${functionName}(${argsList})`);
            operationLines.push(`\t\tif result then`);
            operationLines.push(`\t\t\treaper.SetExtState(globals.SECTION, globals.KEYS.script_output, result, false)`);
            operationLines.push(`\t\tend`);
        }

        // Clean up input parameters from state
        for (const paramName of paramNames) {
            operationLines.push(`\t\treaper.DeleteExtState(globals.SECTION, "${paramName}", true)`);
        }

        operationLines.push(`\tend),`);
        operationLines.push('');

        const operationCode = operationLines.join('\n');
        operations.push(operationCode);
    }
}

// Add imports to the Lua code
for (const importStatement of imports) {
    luaRpcCode += `${importStatement}\n`;
}

luaRpcCode += `\nlocal operations = {\n`;

// Add all operations
for (const operation of operations) {
    luaRpcCode += operation;
}

luaRpcCode += `}

-- Main execution logic
local operation = reaper.GetExtState(globals.SECTION, globals.KEYS.operation)
if not operation or operation == "" then
    reaper.ShowConsoleMsg("No operation specified. Exiting.\\n")
    return
end

if operations[operation] then
    operations[operation]()
    reaper.DeleteExtState(globals.SECTION, globals.KEYS.operation, true)
else
    reaper.ShowConsoleMsg("Unknown operation: " .. operation .. "\\n")
end
`;

const outputPath = path.join(__dirname, '../lua/generated_rpc.lua');
fs.writeFileSync(outputPath, luaRpcCode);
console.log(`Generated Lua RPC code to ${outputPath}`);