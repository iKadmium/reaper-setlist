---@diagnostic disable
-- Bundled by luabundle {"version":"1.7.0"}
local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}

	local register
	local modules = {}

	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]

		if loadedModule then
			if loadedModule == loadingPlaceholder then
				return nil
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '\"' .. name .. '\"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name)
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end

		return loadedModule
	end

	return require, loaded, register, modules
end)(require)
__bundle_register("__root", function(require, _LOADED, __bundle_register, __bundle_modules)
local Globals = require("globals")
local Operations = require("operations_registry")
local Install = require("operations.install")

-- Main execution logic
local operation = reaper.GetExtState(Globals.SECTION, Globals.KEYS.operation)
if not operation or operation == "" then
    local _, _, _, cmdId = reaper.get_action_context()
    local named_command = reaper.ReverseNamedCommandLookup(cmdId)
    local saved_action_id = reaper.GetExtState(Globals.SECTION, Globals.KEYS.script_action_id)
    if saved_action_id == "" or named_command ~= saved_action_id then
        -- If the script is just called by Reaper without an operation and the project root folder is not set,
        -- it's probably the initial installation request
        Install()
        reaper.ShowConsoleMsg("Installation completed.\n")
        return
    else
        reaper.ShowConsoleMsg("No operation specified. Exiting.\n")
        return
    end
end

if Operations[operation] then
    Operations[operation]()
    reaper.DeleteExtState(Globals.SECTION, Globals.KEYS.operation, true)
else
    reaper.ShowConsoleMsg("Unknown operation: " .. operation .. "\n")
end

end)
__bundle_register("operations.install", function(require, _LOADED, __bundle_register, __bundle_modules)
local Globals = require("globals")

---@return nil
local function Install()
    -- Get the script filename
    local _, filename, _, _, _, _, _, _ = reaper.get_action_context()
    if not filename or filename == "" then
        reaper.ShowConsoleMsg("No script filename found. Exiting installation.\n")
        return
    end

    -- this action id is a red herring - it's temporary and subject to change
    local action_id = reaper.AddRemoveReaScript(true, 0, filename, true)
    -- get the permanent ID of the action
    local permanent_id = reaper.ReverseNamedCommandLookup(action_id)

    reaper.SetExtState(Globals.SECTION, Globals.KEYS.script_action_id, "_" .. permanent_id, true)
end

return Install

end)
__bundle_register("globals", function(require, _LOADED, __bundle_register, __bundle_modules)
--- @class Globals
local Globals = {
    SECTION = "ReaperSetlist",
    KEYS = {
        operation = "Operation",
        project_root_folder = "ProjectRoot",
        script_action_id = "ScriptActionId"
    }
}

return Globals

end)
__bundle_register("operations_registry", function(require, _LOADED, __bundle_register, __bundle_modules)
-- Generated by ts-morph script. Do not edit manually!

---@param func function
---@return function
local function safe_operation(func)
    return function()
        local success, err = pcall(func)
        if not success then
            reaper.ShowConsoleMsg("Error: " .. tostring(err) .. "\n")
        end
    end
end

local Globals = require("globals")
local json = require("json")
local ListProjects = require("operations/list_projects")
local TestProjectsFolder = require("operations/test_projects_folder")
local OpenProject = require("operations/open_project")
local TestActionId = require("operations/test_action_id")
local GetProjectLength = require("operations/get_project_length")
local GetOpenTabs = require("operations/get_open_tabs")
local WriteChunkedData = require("operations/write_chunked_data")
local DeleteState = require("operations/delete_state")

---@class ReaperTab
---@field index number
---@field name string
---@field length number
---@field dirty boolean

local Operations = {
	["listProjects"] = safe_operation(function()
		local projects = ListProjects()

		if projects == nil or projects == '' then
			error("Operation listProjects failed to return required output: projects")
		end

		reaper.SetExtState(Globals.SECTION, "projects", json.encode(projects), false)
	end),

	["testProjectsFolder"] = safe_operation(function()
		local folderPath = reaper.GetExtState(Globals.SECTION, "folderPath")
		if folderPath == nil or folderPath == "" then
			error("Missing required parameter: folderPath")
		end

		local valid, message = TestProjectsFolder(folderPath)

		if valid == nil or valid == '' then
			error("Operation testProjectsFolder failed to return required output: valid")
		end

		reaper.SetExtState(Globals.SECTION, "valid", valid and "true" or "false", false)
		if message == nil or message == '' then
			error("Operation testProjectsFolder failed to return required output: message")
		end

		reaper.SetExtState(Globals.SECTION, "message", message, false)
		reaper.DeleteExtState(Globals.SECTION, "folderPath", true)
	end),

	["openProject"] = safe_operation(function()
		local projectPath = reaper.GetExtState(Globals.SECTION, "projectPath")
		if projectPath == nil or projectPath == "" then
			error("Missing required parameter: projectPath")
		end

		OpenProject(projectPath)

		reaper.DeleteExtState(Globals.SECTION, "projectPath", true)
	end),

	["testActionId"] = safe_operation(function()
		local testNonce = reaper.GetExtState(Globals.SECTION, "testNonce")
		if testNonce == nil or testNonce == "" then
			error("Missing required parameter: testNonce")
		end

		local testOutput = TestActionId(testNonce)

		if testOutput == nil or testOutput == '' then
			error("Operation testActionId failed to return required output: testOutput")
		end

		reaper.SetExtState(Globals.SECTION, "testOutput", testOutput, false)
		reaper.DeleteExtState(Globals.SECTION, "testNonce", true)
	end),

	["getProjectLength"] = safe_operation(function()
		local projectLength = GetProjectLength()

		if projectLength == nil or projectLength == '' then
			error("Operation getProjectLength failed to return required output: projectLength")
		end

		reaper.SetExtState(Globals.SECTION, "projectLength", tostring(projectLength), false)
	end),

	["getOpenTabs"] = safe_operation(function()
		local tabs, activeIndex = GetOpenTabs()

		if tabs == nil or tabs == '' then
			error("Operation getOpenTabs failed to return required output: tabs")
		end

		reaper.SetExtState(Globals.SECTION, "tabs", json.encode(tabs), false)
		if activeIndex == nil or activeIndex == '' then
			error("Operation getOpenTabs failed to return required output: activeIndex")
		end

		reaper.SetExtState(Globals.SECTION, "activeIndex", tostring(activeIndex), false)
	end),

	["writeChunkedData"] = safe_operation(function()
		local section = reaper.GetExtState(Globals.SECTION, "section")
		if section == nil or section == "" then
			error("Missing required parameter: section")
		end

		local key = reaper.GetExtState(Globals.SECTION, "key")
		if key == nil or key == "" then
			error("Missing required parameter: key")
		end

		local chunks_length = reaper.GetExtState(Globals.SECTION, "chunks_length")
		if chunks_length == nil or chunks_length == "" then
			error("Missing required parameter: chunks_length")
		end

		local chunks = {}
		for i = 0, (tonumber(chunks_length) - 1) do
			local chunk = reaper.GetExtState(Globals.SECTION, "chunks_" .. i)
			if chunk and chunk ~= "" then
				chunks[i + 1] = chunk
			else
				error("Missing chunk for chunks at index " .. i)
			end
		end

		WriteChunkedData(section, key, chunks)

		reaper.DeleteExtState(Globals.SECTION, "section", true)
		reaper.DeleteExtState(Globals.SECTION, "key", true)
		reaper.DeleteExtState(Globals.SECTION, "chunks", true)
	end),

	["deleteState"] = safe_operation(function()
		local section = reaper.GetExtState(Globals.SECTION, "section")
		if section == nil or section == "" then
			error("Missing required parameter: section")
		end

		local key = reaper.GetExtState(Globals.SECTION, "key")
		if key == nil or key == "" then
			error("Missing required parameter: key")
		end

		DeleteState(section, key)

		reaper.DeleteExtState(Globals.SECTION, "section", true)
		reaper.DeleteExtState(Globals.SECTION, "key", true)
	end),
}

return Operations
end)
__bundle_register("operations/delete_state", function(require, _LOADED, __bundle_register, __bundle_modules)
---@param state string The state table from which the key should be deleted
---@param key string The key to delete from the state table
local function DeleteState(state, key)
    reaper.DeleteExtState(state, key, false)
end

return DeleteState

end)
__bundle_register("operations/write_chunked_data", function(require, _LOADED, __bundle_register, __bundle_modules)
---@param section string
---@param key string
---@param chunks string[]
---@return nil
local function WriteChunkedData(section, key, chunks)
    -- join the chunks into a single string
    local data = table.concat(chunks)
    reaper.SetExtState(section, key, data, true)
end

return WriteChunkedData

end)
__bundle_register("operations/get_open_tabs", function(require, _LOADED, __bundle_register, __bundle_modules)
---@return ReaperTab[]
---@return number active_index
local GetOpenTabs = function()
    ---@type ReaperTab[]
    local tabs = {}
    local tab_index = 0

    local active_project = reaper.EnumProjects(-1)
    local active_project_index = -1;

    while true do
        local proj = reaper.EnumProjects(tab_index)
        if proj == nil then
            break
        end

        local tab_name = reaper.GetProjectName(proj)
        if not tab_name or tab_name == "" then
            break
        end

        local duration = reaper.GetProjectLength(proj)

        -- Normalize the path to ensure consistency
        local normalized_tab_name = tab_name:gsub("\\", "/")

        local is_dirty = reaper.IsProjectDirty(proj) == 1
        local is_active = (proj == active_project)
        if is_active then
            active_project_index = tab_index
        end

        ---@type ReaperTab
        local tab = {
            index = tab_index,
            name = normalized_tab_name,
            dirty = is_dirty,
            length = duration
        }

        table.insert(tabs, tab)
        tab_index = tab_index + 1
    end

    return tabs, active_project_index
end

return GetOpenTabs

end)
__bundle_register("operations/get_project_length", function(require, _LOADED, __bundle_register, __bundle_modules)
---@return number project_length
local function GetLength()
    -- Get the current project length in seconds
    local project = reaper.EnumProjects(-1)
    local project_length = reaper.GetProjectLength(project)
    return project_length
end

return GetLength

end)
__bundle_register("operations/test_action_id", function(require, _LOADED, __bundle_register, __bundle_modules)
---comment Test the action ID with a nonce value.
---@param nonce string
---@return string
local function TestActionId(nonce)
    local testNonce = nonce
    if not testNonce or testNonce == "" then
        error("Missing required parameter: testNonce")
    end

    local result = "Test action ID received: " .. testNonce
    return result
end

return TestActionId

end)
__bundle_register("operations/open_project", function(require, _LOADED, __bundle_register, __bundle_modules)
local Globals = require("globals")

---comment Open a Reaper project from a specified path, relative to the project root.
---@param project_path string
local function OpenProject(project_path)
    if not project_path or project_path == "" then
        reaper.ShowConsoleMsg("No project path specified.\n")
        return
    end

    -- Normalize the path to use forward slashes
    project_path = project_path:gsub("\\", "/")

    -- Get the project root folder from Reaper's project settings
    local project_root_folder = reaper.GetExtState(Globals.SECTION, Globals.KEYS.project_root_folder)
    local full_project_path = project_root_folder .. "/" .. project_path

    -- Open the project
    reaper.Main_openProject(full_project_path)
end

return OpenProject

end)
__bundle_register("operations/test_projects_folder", function(require, _LOADED, __bundle_register, __bundle_modules)
local NormalizePath = require("normalize_path")
local ListRppFilesRecursive = require("list_rpp_files")

local MAX_RUNTIME_SECONDS = 10

---@param folderPath string
---@return boolean valid
---@return string message
local function TestProjectsFolder(folderPath)
    local project_root_folder = NormalizePath(folderPath)
    project_root_folder = project_root_folder:gsub("/$", "")

    -- Record start time for timeout checking
    local start_time = reaper.time_precise()

    -- Use pcall to catch timeout errors
    local success, result = pcall(function()
        return ListRppFilesRecursive(project_root_folder, project_root_folder, start_time, MAX_RUNTIME_SECONDS)
    end)

    if not success then
        -- Check if it's a timeout error
        if result:match("^TIMEOUT:") then
            reaper.ShowMessageBox(
                "Operation timed out after " .. MAX_RUNTIME_SECONDS .. " seconds. Consider reducing the search scope.",
                "List Projects Timeout", 0)
            return false, "Operation timed out" -- Return empty list on timeout
        else
            -- Re-throw other errors
            return false, tostring(result)
        end
    end

    local project_files = result

    table.sort(project_files, function(a, b)
        return a:lower() < b:lower()
    end)

    if #project_files == 0 then
        return false, "No project files found in the specified folder."
    end

    return true, "Found " .. #project_files .. " project files in the specified folder."
end

return TestProjectsFolder;

end)
__bundle_register("list_rpp_files", function(require, _LOADED, __bundle_register, __bundle_modules)
local GetRelativePath = require("relative_path")
local NormalizePath = require("normalize_path")

---@param current_dir string
---@param base_path_for_relative string
---@param start_time number
---@param max_runtime_seconds number
---@return string[]
local function ListRppFilesRecursive(current_dir, base_path_for_relative, start_time, max_runtime_seconds)
    ---@type string[]
    local project_files = {}

    -- Check if we've exceeded the maximum runtime
    local current_time = reaper.time_precise()
    if current_time - start_time > max_runtime_seconds then
        error("TIMEOUT: Operation exceeded " .. max_runtime_seconds .. " seconds")
    end

    current_dir = NormalizePath(current_dir)
    base_path_for_relative = NormalizePath(base_path_for_relative)

    -- Step 1: Enumerate files in the current directory
    local file_index = 0
    while true do
        local filename = reaper.EnumerateFiles(current_dir, file_index)
        if not filename then
            break
        end

        -- Check if it's an .rpp file (case-insensitive)
        if filename:lower():match("%.rpp$") then
            local full_path = current_dir .. "/" .. filename
            local relative_path = GetRelativePath(full_path, base_path_for_relative)
            table.insert(project_files, relative_path)
        end
        file_index = file_index + 1
    end

    -- Step 2: Enumerate subdirectories and recurse
    local subdir_index = 0
    while true do
        local dirname = reaper.EnumerateSubdirectories(current_dir, subdir_index)
        if not dirname then
            break
        end

        -- Skip special directories and hidden directories
        if dirname ~= "." and dirname ~= ".." and not dirname:match("^%.") then
            local full_subdir_path = current_dir .. "/" .. dirname
            local subdir_files = ListRppFilesRecursive(full_subdir_path, base_path_for_relative, start_time,
                max_runtime_seconds)

            -- Use ipairs for better performance with arrays
            for _, file in ipairs(subdir_files) do
                table.insert(project_files, file)
            end
        end
        subdir_index = subdir_index + 1
    end

    return project_files
end

return ListRppFilesRecursive

end)
__bundle_register("normalize_path", function(require, _LOADED, __bundle_register, __bundle_modules)
---@param path string
---@return string
local function NormalizePath(path)
    local normalized = path:gsub("\\", "/")
    return normalized
end

return NormalizePath

end)
__bundle_register("relative_path", function(require, _LOADED, __bundle_register, __bundle_modules)
---@param full_path string
---@param base_path string
---@return string
local function GetRelativePath(full_path, base_path)
    -- Ensure both paths end consistently for proper matching
    local normalized_base = base_path:gsub("/$", "") .. "/"
    local normalized_full = full_path:gsub("\\", "/")

    if normalized_full:sub(1, #normalized_base) == normalized_base then
        return normalized_full:sub(#normalized_base + 1)
    end
    return normalized_full -- fallback to full path if base not found
end

return GetRelativePath

end)
__bundle_register("operations/list_projects", function(require, _LOADED, __bundle_register, __bundle_modules)
local Globals = require("globals")
local ListRppFilesRecursive = require("list_rpp_files")
local NormalizePath = require("normalize_path")

local MAX_RUNTIME_SECONDS = 10

---Returns a list of .rpp files in the project root folder and its subfolders
---@return string[]
local function ListProjects()
    local project_root_folder = reaper.GetExtState(Globals.SECTION, Globals.KEYS.project_root_folder)
    if not project_root_folder or project_root_folder == "" then
        error("Project root folder is not set. Cannot list files.")
    end

    project_root_folder = NormalizePath(project_root_folder)
    project_root_folder = project_root_folder:gsub("/$", "")

    -- Record start time for timeout checking
    local start_time = reaper.time_precise()

    -- Use pcall to catch timeout errors
    local success, result = pcall(function()
        return ListRppFilesRecursive(project_root_folder, project_root_folder, start_time, MAX_RUNTIME_SECONDS)
    end)

    if not success then
        -- Check if it's a timeout error
        if result:match("^TIMEOUT:") then
            reaper.ShowMessageBox(
                "Operation timed out after " .. MAX_RUNTIME_SECONDS .. " seconds. Consider reducing the search scope.",
                "List Projects Timeout", 0)
            return {} -- Return empty list on timeout
        else
            -- Re-throw other errors
            error(result)
        end
    end

    local project_files = result

    table.sort(project_files, function(a, b)
        return a:lower() < b:lower()
    end)

    return project_files
end

return ListProjects

end)
__bundle_register("json", function(require, _LOADED, __bundle_register, __bundle_modules)
--
-- json.lua
--
-- Copyright (c) 2020 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
    ["\\"] = "\\",
    ["\""] = "\"",
    ["\b"] = "b",
    ["\f"] = "f",
    ["\n"] = "n",
    ["\r"] = "r",
    ["\t"] = "t",
}

local escape_char_map_inv = { ["/"] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end


local function escape_char(c)
    return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
    return "null"
end


local function encode_table(val, stack)
    local res = {}
    stack = stack or {}

    -- Circular reference?
    if stack[val] then error("circular reference") end

    stack[val] = true

    if rawget(val, 1) ~= nil or next(val) == nil then
        -- Treat as array -- check keys are valid and it is not sparse
        local n = 0
        for k in pairs(val) do
            if type(k) ~= "number" then
                error("invalid table: mixed or invalid key types")
            end
            n = n + 1
        end
        if n ~= #val then
            error("invalid table: sparse array")
        end
        -- Encode
        for i, v in ipairs(val) do
            table.insert(res, encode(v, stack))
        end
        stack[val] = nil
        return "[" .. table.concat(res, ",") .. "]"
    else
        -- Treat as an object
        for k, v in pairs(val) do
            if type(k) ~= "string" then
                error("invalid table: mixed or invalid key types")
            end
            table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
        end
        stack[val] = nil
        return "{" .. table.concat(res, ",") .. "}"
    end
end


local function encode_string(val)
    return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
    -- Check for NaN, -inf and inf
    if val ~= val or val <= -math.huge or val >= math.huge then
        error("unexpected number value '" .. tostring(val) .. "'")
    end
    return string.format("%.14g", val)
end


local type_func_map = {
    ["nil"] = encode_nil,
    ["table"] = encode_table,
    ["string"] = encode_string,
    ["number"] = encode_number,
    ["boolean"] = tostring,
}


encode = function(val, stack)
    local t = type(val)
    local f = type_func_map[t]
    if f then
        return f(val, stack)
    end
    error("unexpected type '" .. t .. "'")
end


function json.encode(val)
    return (encode(val))
end

-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[select(i, ...)] = true
    end
    return res
end

local space_chars  = create_set(" ", "\t", "\r", "\n")
local delim_chars  = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals     = create_set("true", "false", "null")

local literal_map  = {
    ["true"] = true,
    ["false"] = false,
    ["null"] = nil,
}


local function next_char(str, idx, set, negate)
    for i = idx, #str do
        if set[str:sub(i, i)] ~= negate then
            return i
        end
    end
    return #str + 1
end


local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error(string.format("%s at line %d col %d", msg, line_count, col_count))
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
            f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error(string.format("invalid unicode codepoint '%x'", n))
end


local function parse_unicode_escape(s)
    local n1 = tonumber(s:sub(1, 4), 16)
    local n2 = tonumber(s:sub(7, 10), 16)
    -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")
        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                    or str:match("^%x%x%x%x", j + 1)
                    or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1
        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
    local x = next_char(str, i, delim_chars)
    local s = str:sub(i, x - 1)
    local n = tonumber(s)
    if not n then
        decode_error(str, i, "invalid number '" .. s .. "'")
    end
    return n, x
end


local function parse_literal(str, i)
    local x = next_char(str, i, delim_chars)
    local word = str:sub(i, x - 1)
    if not literals[word] then
        decode_error(str, i, "invalid literal '" .. word .. "'")
    end
    return literal_map[word], x
end


local function parse_array(str, i)
    local res = {}
    local n = 1
    i = i + 1
    while 1 do
        local x
        i = next_char(str, i, space_chars, true)
        -- Empty / end of array?
        if str:sub(i, i) == "]" then
            i = i + 1
            break
        end
        -- Read token
        x, i = parse(str, i)
        res[n] = x
        n = n + 1
        -- Next token
        i = next_char(str, i, space_chars, true)
        local chr = str:sub(i, i)
        i = i + 1
        if chr == "]" then break end
        if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
    end
    return res, i
end


local function parse_object(str, i)
    local res = {}
    i = i + 1
    while 1 do
        local key, val
        i = next_char(str, i, space_chars, true)
        -- Empty / end of object?
        if str:sub(i, i) == "}" then
            i = i + 1
            break
        end
        -- Read key
        if str:sub(i, i) ~= '"' then
            decode_error(str, i, "expected string for key")
        end
        key, i = parse(str, i)
        -- Read ':' delimiter
        i = next_char(str, i, space_chars, true)
        if str:sub(i, i) ~= ":" then
            decode_error(str, i, "expected ':' after key")
        end
        i = next_char(str, i + 1, space_chars, true)
        -- Read value
        val, i = parse(str, i)
        -- Set
        res[key] = val
        -- Next token
        i = next_char(str, i, space_chars, true)
        local chr = str:sub(i, i)
        i = i + 1
        if chr == "}" then break end
        if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
    end
    return res, i
end


local char_func_map = {
    ['"'] = parse_string,
    ["0"] = parse_number,
    ["1"] = parse_number,
    ["2"] = parse_number,
    ["3"] = parse_number,
    ["4"] = parse_number,
    ["5"] = parse_number,
    ["6"] = parse_number,
    ["7"] = parse_number,
    ["8"] = parse_number,
    ["9"] = parse_number,
    ["-"] = parse_number,
    ["t"] = parse_literal,
    ["f"] = parse_literal,
    ["n"] = parse_literal,
    ["["] = parse_array,
    ["{"] = parse_object,
}


parse = function(str, idx)
    local chr = str:sub(idx, idx)
    local f = char_func_map[chr]
    if f then
        return f(str, idx)
    end
    decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
    if type(str) ~= "string" then
        error("expected argument of type string, got " .. type(str))
    end
    local res, idx = parse(str, next_char(str, 1, space_chars, true))
    idx = next_char(str, idx, space_chars, true)
    if idx <= #str then
        decode_error(str, idx, "trailing garbage")
    end
    return res
end

return json

end)
return __bundle_require("__root")